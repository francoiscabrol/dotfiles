#!/bin/sh
exec scala -savecompiled "$0" "$@"
!#

import java.io.File
import sys.process._
import scala.concurrent.ExecutionContext.Implicits.global
import concurrent.{Await, Future}
import scala.concurrent.duration._
import java.util.concurrent.TimeoutException
import scala.actors.Actor
import scala.actors.Actor._
import util.control.Breaks._

def run (processBuilder: ProcessBuilder): String = {
  val stdout = new StringBuilder
  val stderr = new StringBuilder
  val status = processBuilder ! ProcessLogger(stdout append _, stderr append _)
  stdout.toString + stderr.toString
}

case class Mwait(message: String) {
  val thread = new Thread {
    override def run {
      print(".")
      breakable {
        while(true) {
          try {
            Thread.sleep(1000)
            print(".")
          } catch {
            case _: Throwable => break
          }
        }
      }
    }
  }

  def start = {
    print(message)
    thread.start
    this
  }

  def done() {
    thread.interrupt()
    print("\r")
  }

}

object Git {
  def branch(dir: File): String = {
    run(Process("git branch", dir) #| "grep \\*")
  }
  def status(dir: File): String = {
    run(Process("git fetch", dir))
    run(Process("git status", dir))
  }
}

object Gstatus {

  implicit class stringColors(val s: String) {
    val RED = "\u001B[31m"
    val GREEN = "\u001B[32m"
    val WHITE = "\u001B[37m"
    val BLUE = "\u001B[34m"
    val RESET = "\u001B[0m"

    def red = RED + s + RESET
    def green = GREEN + s + RESET
    def blue = BLUE + s + RESET
  }

  implicit class FileDecored(file: File) {
    def listDirectories: List[File] = file.listFiles.filter(_.isDirectory).toList
    def isGitRepo: Boolean = file.listFiles.exists(f => f.getName == ".git")
  }

  def gitStatus(dir: File): String = Git.status(dir) match {
      case x if x.contains("not staged") => "Need to stage files".red
      case x if x.contains("up-to-date") => "Up to date"
      case x if x.contains("git pull") => "Need to pull".blue
      case x if x.contains("nothing to commit") => "nothing to commit. Not synchonized with a remote"
      case "error" => "well... something unusual".red
      case x => x
    }

  def gitInformations(directories: List[File]): List[String] = {
    val futures = directories map((dir) => {
        Future {
          val combinedFuture = for {
              r1 <- Future { gitStatus(dir) }
              r2 <- Future { Git.branch(dir).trim }
            } yield (r1, r2)
          val (state, branch) = Await.result(combinedFuture, 10.seconds)
          dir + "-" + branch.blue + ": " + state.green
        }
      })
    Await.result(Future.sequence(futures), 10.seconds)
  }

  def main(args: Array[String]) {
    val mWait = Mwait("Please wait").start
    val directories = new File(".").listDirectories.filter(!_.isHidden)
    val (gitRepos, notGitRepos) = directories.partition(_.isGitRepo)
    notGitRepos foreach((dir) => {
        println(dir + ": Not a Git repo")
    })
    try {
      val r = gitInformations(gitRepos)
      mWait.done
      r foreach println
    } catch {
      case _: TimeoutException => println("Timeout")
    }
  }
}

Gstatus.main(args)

